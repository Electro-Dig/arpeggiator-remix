<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ†å½¢éŸ³åºå™¨æµ‹è¯•</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        
        h1 {
            color: #7B4394;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(123, 67, 148, 0.5);
        }
        
        .test-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #7B4394, #9B59B6);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            background: linear-gradient(135deg, #9B59B6, #BB79D6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(123, 67, 148, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        #circular-sequencer-test {
            min-height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .info {
            background: rgba(123, 67, 148, 0.1);
            border: 1px solid rgba(123, 67, 148, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: left;
        }
        
        .info h3 {
            color: #7B4394;
            margin-top: 0;
        }
        
        .info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .info li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ åœ†å½¢éŸ³åºå™¨æµ‹è¯•</h1>
        
        <div class="info">
            <h3>ä½¿ç”¨è¯´æ˜ï¼š</h3>
            <ul>
                <li>ç‚¹å‡»åœ†ç¯ä¸Šçš„æ®µæ¥æ¿€æ´»/å–æ¶ˆæ¿€æ´»èŠ‚æ‹</li>
                <li>ä»å¤–åˆ°å†…åˆ†åˆ«æ˜¯ï¼šKickã€Snareã€Hi-hatã€Clapã€Open Hat</li>
                <li>æ¯ä¸ªç¯æœ‰16ä¸ªæ®µï¼Œå¯¹åº”16æ‹éŸ³åº</li>
                <li>æ”¯æŒé¼ æ ‡æ‹–æ‹½æ¥å¿«é€Ÿè®¾ç½®å¤šä¸ªèŠ‚æ‹</li>
                <li>ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®æµ‹è¯•å„ç§åŠŸèƒ½</li>
            </ul>
        </div>
        
        <div class="test-container">
            <div class="controls">
                <button class="btn" onclick="createSequencer()">åˆ›å»ºéŸ³åºå™¨</button>
                <button class="btn" onclick="clearAll()">æ¸…ç©ºæ‰€æœ‰</button>
                <button class="btn" onclick="randomize()">éšæœºåŒ–</button>
                <button class="btn" onclick="testPlayback()">æµ‹è¯•æ’­æ”¾</button>
                <button class="btn" onclick="getPatterns()">è·å–æ¨¡å¼</button>
                <button class="btn" onclick="destroySequencer()">é”€æ¯éŸ³åºå™¨</button>
            </div>
            
            <div id="circular-sequencer-test"></div>
        </div>
        
        <div id="output" class="info" style="display: none;">
            <h3>è¾“å‡ºä¿¡æ¯ï¼š</h3>
            <pre id="output-content"></pre>
        </div>
    </div>

    <script type="module">
        // å¯¼å…¥CircularSequencerç±»
        let CircularSequencer;
        let sequencer = null;
        let playInterval = null;
        let currentStep = 0;
        
        // ä»CustomEditor.jsä¸­æå–CircularSequencerç±»
        async function loadCircularSequencer() {
            try {
                // åŠ¨æ€åˆ›å»ºCircularSequencerç±»
                window.CircularSequencer = class CircularSequencer {
                    constructor(containerId, options = {}) {
                        this.containerId = containerId;
                        this.container = document.getElementById(containerId);
                        
                        // é…ç½®å‚æ•°
                        this.config = {
                            centerX: options.centerX || 250,
                            centerY: options.centerY || 250,
                            innerRadius: options.innerRadius || 60,
                            ringWidth: options.ringWidth || 35,
                            ringGap: options.ringGap || 3,
                            segments: options.segments || 16,
                            ...options
                        };
                        
                        // é¼“å£°é…ç½®
                        this.drumTypes = [
                            { id: 'kick', name: 'Kick', color: '#D72828', emoji: 'ğŸ¥' },
                            { id: 'snare', name: 'Snare', color: '#F36E2F', emoji: 'ğŸ¥' },
                            { id: 'hihat', name: 'Hi-hat', color: '#84C34E', emoji: 'ğŸ©' },
                            { id: 'clap', name: 'Clap', color: '#7B4394', emoji: 'ğŸ‘' },
                            { id: 'openhat', name: 'Open Hat', color: '#4A90E2', emoji: 'ğŸ©' }
                        ];
                        
                        // çŠ¶æ€æ•°æ®
                        this.patterns = {};
                        this.drumTypes.forEach(drum => {
                            this.patterns[drum.id] = new Array(16).fill(false);
                        });
                        
                        // Canvasç›¸å…³
                        this.canvas = null;
                        this.ctx = null;
                        this.animationId = null;
                        this.currentPlayPosition = -1;
                        
                        // äº¤äº’çŠ¶æ€
                        this.isDragging = false;
                        this.lastClickedSegment = null;
                        
                        this.init();
                    }
                    
                    init() {
                        this.createCanvas();
                        this.createLegend();
                        this.setupEventListeners();
                        this.render();
                        console.log('âœ… åœ†å½¢éŸ³åºå™¨å·²åˆå§‹åŒ–');
                    }
                    
                    createCanvas() {
                        // åˆ›å»ºcanvaså…ƒç´ 
                        this.canvas = document.createElement('canvas');
                        this.canvas.width = this.config.centerX * 2;
                        this.canvas.height = this.config.centerY * 2;
                        this.canvas.style.border = '1px solid #333';
                        this.canvas.style.borderRadius = '50%';
                        this.canvas.style.background = 'radial-gradient(circle, #1a1a1a 0%, #000 100%)';
                        this.canvas.style.cursor = 'pointer';
                        
                        this.ctx = this.canvas.getContext('2d');
                        
                        // æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ canvas
                        this.container.innerHTML = '';
                        this.container.appendChild(this.canvas);
                    }
                    
                    createLegend() {
                        const legend = document.createElement('div');
                        legend.className = 'circular-legend';
                        legend.style.display = 'flex';
                        legend.style.justifyContent = 'center';
                        legend.style.gap = '15px';
                        legend.style.flexWrap = 'wrap';
                        legend.style.marginTop = '10px';
                        
                        this.drumTypes.forEach((drum, index) => {
                            const legendItem = document.createElement('div');
                            legendItem.style.display = 'flex';
                            legendItem.style.alignItems = 'center';
                            legendItem.style.gap = '8px';
                            legendItem.style.padding = '6px 12px';
                            legendItem.style.background = 'rgba(255, 255, 255, 0.1)';
                            legendItem.style.borderRadius = '20px';
                            legendItem.style.fontSize = '12px';
                            legendItem.style.color = 'white';
                            legendItem.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                            
                            const colorDot = document.createElement('div');
                            colorDot.style.width = '12px';
                            colorDot.style.height = '12px';
                            colorDot.style.borderRadius = '50%';
                            colorDot.style.backgroundColor = drum.color;
                            colorDot.style.border = '1px solid rgba(255, 255, 255, 0.3)';
                            
                            const label = document.createElement('span');
                            label.textContent = `${drum.emoji} ${drum.name}`;
                            
                            legendItem.appendChild(colorDot);
                            legendItem.appendChild(label);
                            legend.appendChild(legendItem);
                        });
                        
                        this.container.appendChild(legend);
                    }
                    
                    setupEventListeners() {
                        this.canvas.addEventListener('click', (e) => this.handleClick(e));
                        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                        this.canvas.addEventListener('mouseleave', (e) => this.handleMouseUp(e));
                    }
                    
                    // è·å–é¼ æ ‡åœ¨canvasä¸­çš„åæ ‡
                    getMousePos(e) {
                        const rect = this.canvas.getBoundingClientRect();
                        return {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        };
                    }
                    
                    // å°†ç¬›å¡å°”åæ ‡è½¬æ¢ä¸ºæåæ ‡
                    cartesianToPolar(x, y) {
                        const dx = x - this.config.centerX;
                        const dy = y - this.config.centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        let angle = Math.atan2(dy, dx);
                        
                        // è°ƒæ•´è§’åº¦ï¼Œä½¿0åº¦åœ¨é¡¶éƒ¨ï¼Œé¡ºæ—¶é’ˆå¢åŠ 
                        angle = angle + Math.PI / 2;
                        if (angle < 0) angle += 2 * Math.PI;
                        
                        return { distance, angle };
                    }
                    
                    // æ ¹æ®æåæ ‡ç¡®å®šç‚¹å‡»çš„ç¯å’Œæ®µ
                    getSegmentFromPolar(distance, angle) {
                        // ç¡®å®šç¯ï¼ˆä»å¤–åˆ°å†…ï¼š0-4ï¼‰
                        let ring = -1;
                        for (let i = 0; i < this.drumTypes.length; i++) {
                            const innerR = this.config.innerRadius + i * (this.config.ringWidth + this.config.ringGap);
                            const outerR = innerR + this.config.ringWidth;
                            
                            if (distance >= innerR && distance <= outerR) {
                                ring = i;
                                break;
                            }
                        }
                        
                        if (ring === -1) return null;
                        
                        // ç¡®å®šæ®µï¼ˆ0-15ï¼‰
                        const segmentAngle = (2 * Math.PI) / this.config.segments;
                        const segment = Math.floor(angle / segmentAngle) % this.config.segments;
                        
                        return { ring, segment };
                    }
                    
                    // å¤„ç†é¼ æ ‡äº‹ä»¶
                    handleClick(e) {
                        const mousePos = this.getMousePos(e);
                        const polar = this.cartesianToPolar(mousePos.x, mousePos.y);
                        const segment = this.getSegmentFromPolar(polar.distance, polar.angle);
                        
                        if (segment) {
                            this.toggleSegment(segment.ring, segment.segment);
                        }
                    }
                    
                    handleMouseDown(e) {
                        this.isDragging = true;
                        this.handleClick(e);
                    }
                    
                    handleMouseMove(e) {
                        if (!this.isDragging) return;
                        
                        const mousePos = this.getMousePos(e);
                        const polar = this.cartesianToPolar(mousePos.x, mousePos.y);
                        const segment = this.getSegmentFromPolar(polar.distance, polar.angle);
                        
                        if (segment && this.lastClickedSegment) {
                            const key = `${segment.ring}-${segment.segment}`;
                            const lastKey = `${this.lastClickedSegment.ring}-${this.lastClickedSegment.segment}`;
                            
                            if (key !== lastKey) {
                                this.toggleSegment(segment.ring, segment.segment);
                                this.lastClickedSegment = segment;
                            }
                        }
                    }
                    
                    handleMouseUp(e) {
                        this.isDragging = false;
                        this.lastClickedSegment = null;
                    }
                    
                    // åˆ‡æ¢æ®µçš„æ¿€æ´»çŠ¶æ€
                    toggleSegment(ring, segment) {
                        if (ring >= 0 && ring < this.drumTypes.length && segment >= 0 && segment < this.config.segments) {
                            const drumType = this.drumTypes[ring].id;
                            this.patterns[drumType][segment] = !this.patterns[drumType][segment];
                            this.lastClickedSegment = { ring, segment };
                            this.render();
                        }
                    }
                    
                    // æ¸²æŸ“åœ†å½¢éŸ³åºå™¨
                    render() {
                        const ctx = this.ctx;
                        const { centerX, centerY, innerRadius, ringWidth, ringGap, segments } = this.config;
                        
                        // æ¸…ç©ºç”»å¸ƒ
                        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        
                        // ç»˜åˆ¶æ¯ä¸ªç¯
                        this.drumTypes.forEach((drumType, ringIndex) => {
                            const innerR = innerRadius + ringIndex * (ringWidth + ringGap);
                            const outerR = innerR + ringWidth;
                            
                            // ç»˜åˆ¶æ¯ä¸ªæ®µ
                            for (let segmentIndex = 0; segmentIndex < segments; segmentIndex++) {
                                const startAngle = (segmentIndex * 2 * Math.PI / segments) - Math.PI / 2;
                                const endAngle = ((segmentIndex + 1) * 2 * Math.PI / segments) - Math.PI / 2;
                                
                                const isActive = this.patterns[drumType.id][segmentIndex];
                                const isCurrentPlay = segmentIndex === this.currentPlayPosition;
                                
                                // è®¾ç½®é¢œè‰²
                                let color = drumType.color;
                                let alpha = isActive ? 0.8 : 0.2;
                                
                                if (isCurrentPlay) {
                                    alpha = Math.min(alpha + 0.3, 1.0);
                                }
                                
                                // ç»˜åˆ¶æ®µ
                                ctx.beginPath();
                                ctx.arc(centerX, centerY, innerR, startAngle, endAngle);
                                ctx.arc(centerX, centerY, outerR, endAngle, startAngle, true);
                                ctx.closePath();
                                
                                // å¡«å……é¢œè‰²
                                ctx.fillStyle = this.hexToRgba(color, alpha);
                                ctx.fill();
                                
                                // ç»˜åˆ¶è¾¹æ¡†
                                ctx.strokeStyle = this.hexToRgba('#ffffff', 0.1);
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                
                                // å¦‚æœæ˜¯æ¿€æ´»çŠ¶æ€ï¼Œæ·»åŠ å‘å…‰æ•ˆæœ
                                if (isActive) {
                                    ctx.shadowColor = color;
                                    ctx.shadowBlur = 8;
                                    ctx.fill();
                                    ctx.shadowBlur = 0;
                                }
                            }
                        });
                        
                        // ç»˜åˆ¶ä¸­å¿ƒæ ‡ç­¾
                        this.drawCenterLabel();
                        
                        // ç»˜åˆ¶æ’­æ”¾æŒ‡é’ˆ
                        if (this.currentPlayPosition >= 0) {
                            this.drawPlayPointer();
                        }
                    }
                    
                    // ç»˜åˆ¶ä¸­å¿ƒæ ‡ç­¾
                    drawCenterLabel() {
                        const ctx = this.ctx;
                        const { centerX, centerY, innerRadius } = this.config;
                        
                        // ç»˜åˆ¶ä¸­å¿ƒåœ†
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, innerRadius - 5, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // ç»˜åˆ¶æ–‡å­—
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('DRUM', centerX, centerY - 8);
                        ctx.font = '12px Arial';
                        ctx.fillText('SEQUENCER', centerX, centerY + 8);
                    }
                    
                    // ç»˜åˆ¶æ’­æ”¾æŒ‡é’ˆ
                    drawPlayPointer() {
                        const ctx = this.ctx;
                        const { centerX, centerY, innerRadius, ringWidth, ringGap } = this.config;
                        const totalRadius = innerRadius + this.drumTypes.length * (ringWidth + ringGap) + 10;
                        
                        const angle = (this.currentPlayPosition * 2 * Math.PI / this.config.segments) - Math.PI / 2;
                        const endX = centerX + Math.cos(angle) * totalRadius;
                        const endY = centerY + Math.sin(angle) * totalRadius;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(endX, endY);
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        // ç»˜åˆ¶æŒ‡é’ˆå¤´
                        ctx.beginPath();
                        ctx.arc(endX, endY, 4, 0, 2 * Math.PI);
                        ctx.fillStyle = '#ffffff';
                        ctx.fill();
                    }
                    
                    // å·¥å…·æ–¹æ³•ï¼šå°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸ºRGBA
                    hexToRgba(hex, alpha) {
                        const r = parseInt(hex.slice(1, 3), 16);
                        const g = parseInt(hex.slice(3, 5), 16);
                        const b = parseInt(hex.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    }
                    
                    // è®¾ç½®æ’­æ”¾ä½ç½®
                    setPlayPosition(position) {
                        this.currentPlayPosition = position;
                        this.render();
                    }
                    
                    // è·å–å½“å‰æ¨¡å¼
                    getPatterns() {
                        return { ...this.patterns };
                    }
                    
                    // è®¾ç½®æ¨¡å¼
                    setPatterns(patterns) {
                        this.patterns = { ...patterns };
                        this.render();
                    }
                    
                    // æ¸…ç©ºæ‰€æœ‰æ¨¡å¼
                    clearAll() {
                        this.drumTypes.forEach(drum => {
                            this.patterns[drum.id] = new Array(16).fill(false);
                        });
                        this.render();
                    }
                    
                    // éšæœºåŒ–æ¨¡å¼
                    randomize() {
                        this.drumTypes.forEach(drum => {
                            this.patterns[drum.id] = new Array(16).fill(false).map(() => Math.random() > 0.7);
                        });
                        this.render();
                    }
                    
                    // é”€æ¯
                    destroy() {
                        if (this.animationId) {
                            cancelAnimationFrame(this.animationId);
                        }
                        if (this.container) {
                            this.container.innerHTML = '';
                        }
                    }
                };
                
                console.log('âœ… CircularSequencerç±»å·²åŠ è½½');
            } catch (error) {
                console.error('âŒ åŠ è½½CircularSequencerå¤±è´¥:', error);
            }
        }
        
        // å…¨å±€å‡½æ•°
        window.createSequencer = function() {
            if (sequencer) {
                sequencer.destroy();
            }
            
            sequencer = new window.CircularSequencer('circular-sequencer-test', {
                centerX: 200,
                centerY: 200,
                innerRadius: 50,
                ringWidth: 30,
                ringGap: 2,
                segments: 16
            });
            
            showOutput('éŸ³åºå™¨å·²åˆ›å»º');
        };
        
        window.clearAll = function() {
            if (sequencer) {
                sequencer.clearAll();
                showOutput('æ‰€æœ‰æ¨¡å¼å·²æ¸…ç©º');
            } else {
                showOutput('è¯·å…ˆåˆ›å»ºéŸ³åºå™¨');
            }
        };
        
        window.randomize = function() {
            if (sequencer) {
                sequencer.randomize();
                showOutput('æ¨¡å¼å·²éšæœºåŒ–');
            } else {
                showOutput('è¯·å…ˆåˆ›å»ºéŸ³åºå™¨');
            }
        };
        
        window.testPlayback = function() {
            if (!sequencer) {
                showOutput('è¯·å…ˆåˆ›å»ºéŸ³åºå™¨');
                return;
            }
            
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
                sequencer.setPlayPosition(-1);
                showOutput('æ’­æ”¾å·²åœæ­¢');
                return;
            }
            
            currentStep = 0;
            playInterval = setInterval(() => {
                sequencer.setPlayPosition(currentStep);
                currentStep = (currentStep + 1) % 16;
            }, 200);
            
            showOutput('å¼€å§‹æµ‹è¯•æ’­æ”¾ï¼ˆæ¯200msä¸€æ­¥ï¼‰');
        };
        
        window.getPatterns = function() {
            if (sequencer) {
                const patterns = sequencer.getPatterns();
                showOutput('å½“å‰æ¨¡å¼ï¼š\n' + JSON.stringify(patterns, null, 2));
            } else {
                showOutput('è¯·å…ˆåˆ›å»ºéŸ³åºå™¨');
            }
        };
        
        window.destroySequencer = function() {
            if (sequencer) {
                if (playInterval) {
                    clearInterval(playInterval);
                    playInterval = null;
                }
                sequencer.destroy();
                sequencer = null;
                showOutput('éŸ³åºå™¨å·²é”€æ¯');
            } else {
                showOutput('æ²¡æœ‰éŸ³åºå™¨éœ€è¦é”€æ¯');
            }
        };
        
        function showOutput(message) {
            const output = document.getElementById('output');
            const content = document.getElementById('output-content');
            content.textContent = message;
            output.style.display = 'block';
            
            // 3ç§’åè‡ªåŠ¨éšè—
            setTimeout(() => {
                output.style.display = 'none';
            }, 3000);
        }
        
        // åˆå§‹åŒ–
        await loadCircularSequencer();
        console.log('ğŸ¯ åœ†å½¢éŸ³åºå™¨æµ‹è¯•é¡µé¢å·²åŠ è½½');
    </script>
</body>
</html>
